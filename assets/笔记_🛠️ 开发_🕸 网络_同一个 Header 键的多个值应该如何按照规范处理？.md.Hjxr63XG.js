import{_ as d,c as h,J as a,m as t,a as e,w as r,V as n,E as s,o as _}from"./chunks/framework.WH0rnJL5.js";const p="/assets/rfc2616-screenshot-01.FEH8nXlI.png",f="/assets/rfc2616-screenshot-02.pyG2Kz1f.png",G=JSON.parse('{"title":"同一个 Header 键的多个值应该如何按照规范处理？","description":"","frontmatter":{"tags":["计算机/网络/协议/HTTP","计算机/网络/协议/HTTP/Header"]},"headers":[],"relativePath":"笔记/🛠️ 开发/🕸 网络/同一个 Header 键的多个值应该如何按照规范处理？.md","filePath":"笔记/🛠️ 开发/🕸 网络/同一个 Header 键的多个值应该如何按照规范处理？.md"}'),m={name:"笔记/🛠️ 开发/🕸 网络/同一个 Header 键的多个值应该如何按照规范处理？.md"},u=t("h1",{id:"同一个-header-键的多个值应该如何按照规范处理",tabindex:"-1"},[e("同一个 Header 键的多个值应该如何按照规范处理？ "),t("a",{class:"header-anchor",href:"#同一个-header-键的多个值应该如何按照规范处理","aria-label":'Permalink to "同一个 Header 键的多个值应该如何按照规范处理？"'},"​")],-1),g=n('<h5 id="文档版本" tabindex="-1">文档版本 <a class="header-anchor" href="#文档版本" aria-label="Permalink to &quot;文档版本&quot;">​</a></h5><table><thead><tr><th>编辑者</th><th>版本</th><th>变更日期</th><th>变更说明</th></tr></thead><tbody><tr><td>Neko</td><td>v1.0.0</td><td>2022-05-30</td><td>创建</td></tr></tbody></table><p>曾经想过这个问题，但是似乎自己没有遇到过类似的情况所以没深究，今天在 Mi Home 群和 Rikumi 讨论「同一个 Header 键的多个值应该如何发送和接收」的时候好奇就去查了一下。</p>',3),b=t("p",null,[t("img",{src:p,alt:""})],-1),T=t("code",null,"1#cache-directive",-1),C=n('<p><img src="'+f+`" alt="rfc2616-screenshot-02"></p><p>根据 RFC2616 第二部分的定义，任何 <code>#</code> 字符开头的字段结构都应该是一个列表，「每一个元素之间应该使用一个或是多个英文逗号 <code>,</code> 和<strong>可选</strong>的线性空格（LWS）进行连接」。</p><p>我们可以因此解读以下报文：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Cache-Control: no-cache</span></span>
<span class="line"><span>Cache-Control: no-store</span></span></code></pre></div><p>为下面的形式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Cache-Control: no-cache, no-store</span></span></code></pre></div>`,6),v=t("blockquote",null,[t("p",null,'A recipient MAY combine multiple header fields with the same field name into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma. The order in which header fields with the same field name are received is therefore significant to the interpretation of the combined field value; a proxy MUST NOT change the order of these field values when forwarding a message.')],-1),P=t("p",null,[e("翻译过来的话就是说：收件方可以将具有相同字段名的多个标头字段合并为一个 "),t("code",null,'"field-name: field-value"'),e(" 对，而不改变信息的语义。这个方法是将每个随后的标头字段值依次附加到后面的字段值依次追加到合并的字段值中，用逗号隔开。顺序是接收具有相同字段名的标题字段的顺序。因此，接收具有相同字段名的头字段的顺序对解释组合字段值很重要。代理在转发消息时不得改变这些字段值的顺序。转发消息时，代理不得改变这些字段值的顺序。")],-1),k=t("p",null,[e("所以正确的做法是 "),t("strong",null,"对同一个 Header 键的多个值使用英文逗号进行间隔并按照传输顺序拼接在一起"),e("。")],-1),H=t("h2",{id:"贡献者",tabindex:"-1"},[e("贡献者 "),t("a",{class:"header-anchor",href:"#贡献者","aria-label":'Permalink to "贡献者"'},"​")],-1),w=t("h2",{id:"文件历史",tabindex:"-1"},[e("文件历史 "),t("a",{class:"header-anchor",href:"#文件历史","aria-label":'Permalink to "文件历史"'},"​")],-1);function N(x,y,S,V,R,A){const l=s("NolebasePageProperties"),o=s("VPNolebaseInlineLinkPreview"),i=s("NolebaseGitContributors"),c=s("NolebaseGitChangelog");return _(),h("div",null,[u,a(l),g,t("p",null,[e("是在这篇文章看到讲解："),a(o,{href:"https://stackoverflow.com/questions/4371328/are-duplicate-http-response-headers-acceptable",target:"_blank",rel:"noreferrer"},{default:r(()=>[e("Are Duplicate HTTP Response Headers acceptable? (重复的 HTTP 响应标头值应该是可被接受的吗？) - Stack Overflow")]),_:1}),e(" 讲解中提到了一个案例 "),a(o,{href:"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9",target:"_blank",rel:"noreferrer"},{default:r(()=>[e("RFC2616 Header Field Definitions (标头字段定义)")]),_:1}),e("，在这篇 RFC 针对 Cache-Control 相关的标头定义中提到了类似的「层级」：")]),b,t("p",null,[e("顺藤摸瓜找到 RFC2616 的第二部分："),a(o,{href:"https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2",target:"_blank",rel:"noreferrer"},{default:r(()=>[e("Notational Conventions and Generic Grammar (符号约定和通用语法)")]),_:1}),e(" 可以看到对上面提到的 "),T,e(" 层级的说明。")]),C,t("p",null,[e("再根据 "),a(o,{href:"https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.2",target:"_blank",rel:"noreferrer"},{default:r(()=>[e("RFC7230 Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing (超文本传输协议 (HTTP/1.1): 消息语法和路由)")]),_:1}),e(" 中 "),a(o,{href:"https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.2",target:"_blank",rel:"noreferrer"},{default:r(()=>[e("3.2.2")]),_:1}),e(". Field Order 字段顺序) 章节更详细的定义：")]),v,P,k,H,a(i),w,a(c)])}const I=d(m,[["render",N]]);export{G as __pageData,I as default};
